## 软件设计

根据软件工程这门课做的一些总结。拥有思想的代码才更持久

| 作者 | MagnetoWang                                                  |
| ---- | ------------------------------------------------------------ |
| 邮箱 | 暂无                                                         |
| 说明 | 根据软件工程这门课，梳理下内容，整理成笔记。                 |
| 注意 | 请不要用于商业用途。分享学习经验是种有趣的爱好。             |
| 参考 | 西电计算机学院的软件工程课堂ppt。                            |
| 最后 | 如果需要转载或者引用的话，请标注一下我的github链接吧。https://github.com/MagnetoWang |



[TOC]

### ToDoList

- [ ] 内聚类型有待完善



### 总体设计

#### 抽象

- 抽象：现实世界中一定事物、状态或过程之间总存在着某些相似的方面(共性)。把这些相似的方面集中和概括起来，暂时忽略它们之间的差异，这就是抽象。 



##### 一般抽象过程

- 处理复杂系统的惟一有效的方法是用层次的方式构造和分析它。 
- 一个复杂的动态系统首先可以用一些高级的抽象概念构造和理解，这些高级概念又可以用一些较低级的概念构造和理解，如此进行下去，直至最低层次的具体元素。  

##### 软件工程抽象过程

- 软件工程过程的每一步都是对软件解法的抽象层次的一次精化。 
- 在可行性研究阶段，软件作为系统的一个完整部件。
- 在需求分析期间，软件解法是使用在问题环境内熟悉的方式描述的。
- 当由总体设计向详细设计过渡时，抽象的程度也就随之减少了。
- 最后，当源程序写出来以后，也就达到了抽象的最低层。  

##### 概念

- 信息隐藏：应该这样设计和确定模块，使得一个模块内包含的信息(过程和数据)对于不需要这些信息的模块来说，是不能访问的。 
- 局部化：局部化的概念和信息隐藏概念是密切相关的。所谓局部化是指把一些关系密切的软件元素物理地放得彼此靠近。显然，局部化有助于实现信息隐藏。 

#### 模块方面

##### 模块化

- 模块：是由边界元素限定的相邻程序元素的序列，而且有一个总体标识符代表它。 
- 模块化：就是把程序划分成独立命名且可独立访问的模块，每个模块完成一个子功能，把这些模块集成起来构成一个整体，可以完成指定的功能满足用户的需求。
- 模块化是为了使一个复杂的大型程序能被人的智力所管理，软件应该具备的惟一属性。 
- 如果一个大型程序仅由一个模块组成，它将很难被人所理解。  
- 如果C(P1)>C(P2)，显然E(P1)>E(P2) 
- C(P1+P2)>C(P1)+C(P2) 
- E(P1+P2)>E(P1)+E(P2) 

##### 五条标准

- 模块可分解性 

- 模块可组装性 

- 模块可理解性

- 模块连续性 

- 模块保护性

##### 模块化的作用

- 采用模块化原理可以使软件结构清晰，不仅容易设计也容易阅读和理解。 
- 模块化使软件容易测试和调试，因而有助于提高软件的可靠性。 
- 模块化能够提高软件的可修改性。
- 模块化也有助于软件开发工程的组织管理。 



#### 模块独立 

- 模块独立的概念是模块化、抽象、信息隐藏和局部化概念的直接结果。 
- 希望这样设计软件结构，使得每个模块完成一个相对独立的特定子功能，并且和其他模块之间的关系很简单。 

##### 定性标准度量

- 耦合衡量不同模块彼此间互相依赖(连接)的紧密程度。耦合要低，即每个模块和其他模块之间的关系要简单。
- 内聚衡量一个模块内部各个元素彼此结合的紧密程度。内聚要高，每个模块完成一个相对独立的特定子功能。 

##### 耦合

- 是对一个软件结构内不同模块之间互连程度的度量。 
- 要求：在软件设计中应该追求尽可能松散耦合的系统。 
- 可以研究、测试或维护任何一个模块，而不需要对系统的其他模块有很多了解。
- 模块间联系简单，发生在一处的错误传播到整个系统的可能性就很小； 
- 模块间的耦合程度强烈影响系统的可理解性、可测试性、可靠性和可维护性。

##### 耦合类型

- 非直接耦合/完全独立(no direct coupling) 
  - 如果两个模块中的每一个都能独立地工作而不需要另一个模块的存在，那么它们完全独立 :
  - 在一个软件系统中不可能所有模块之间都没有任何连接。 
- 数据耦合(data coupling) 
  - 如果两个模块彼此间通过参数交换信息，而且交换的信息仅仅是数据，那么这种耦合称为数据耦合 
  - 维护更容易，对一个模块的修改不会是另一个模块产生退化错误。
  - 系统中至少必须存在这种耦合。一般说来，一个系统内可以只包含数据耦合。
  - 数据耦合是理想的目标。 
- 控制耦合(control coupling) 
  - 如果两个模块彼此间传递的信息中有控制信息，这种耦合称为控制耦合。
  - 控制耦合往往是多余的，把模块适当分解之后通常可以用数据耦合代替它。 
  - 被调用的模块需知道调用模块的内部结构和逻辑，降低了重用的可能性 。 
- 特征耦合(stamp coupling) 
  - 当把整个数据结构作为参数传递而被调用的模块只需要使用其中一部分数据元素时，就出现了特征耦合。
  - 被调用的模块可使用的数据多于它确实需要的数据，这将导致对数据的访问失去控制，从而给计算机犯罪提供了机会。 
  - 无论何时把指针作为参数进行传递，都应该仔细检查该耦合。
- 公共环境耦合(common coupling)
  - 当两个或多个模块通过一个公共数据环境相互作用时，它们之间的耦合称为公共环境耦合。公共环境可以是全程变量、共享的通信区、内存的公共覆盖区、任何存储介质上的文件、物理设备等等。 
  - n一个模块往公共环境送数据，另一个模块从公共环境取数据。数据耦合的一种形式，是比较松散的耦合。 
  - 两个模块都既往公共环境送数据又从里面取数据，这种耦合比较紧密，介于数据耦合和控制耦合之间。 
  - 与结构化编程矛盾，生成的代码完全不可读。
  - 潜在危险很大。模块暴露出必需要更多的数据，难以控制数据存取，而且会导致计算机犯罪。 
- 内容耦合(content coupling) 
  - 最高程度的耦合是内容耦合。如果出现下列情况之一，两个模块间就发生了内容耦合。
  - 一个模块访问另一个模块的内部数据。
  - 一个模块不通过正常入口转到另一个模块的内部。
  - 两个模块有一部分程序代码重叠。
  - 一个模块有多个入口。
- 设计原则
  - 尽量使用数据耦合 
  - 少用控制耦合和特征耦合 
  - 限制公共环境耦合的范围 
  - 完全不用内容耦合 



##### 内聚 

- 内聚：标志一个模块内各个元素彼此结合的紧密程度，它是信息隐藏和局部化概念的自然扩展。简单地说，理想内聚的模块只做一件事情 ɴ
- 要求：设计时应该力求做到高内聚，通常中等程度的内聚也是可以采用的，而且效果和高内聚相差不多；但是，低内聚不要使用。 
- 内聚和耦合是密切相关的，模块内的高内聚往往意味着模块间的松耦合。实践表明内聚更重要，应该把更多注意力集中到提高模块的内聚程度上。



##### 内聚类型

- 偶然内聚(coincidental cohesion) 
  - 如果一个模块完成一组任务，这些任务彼此间即使有关系，关系也是很松散的，就叫做偶然内聚。 
  - 模块内各元素之间没有实质性联系，很可能在一种应用场合需要修改这个模块，在另一种应用场合又不允许这种修改，从而陷入困境； 
  - 模块是不可重用的。 
  - 将模块分成更小的模块，每个小模块执行一个操作。
- 逻辑内聚(logical cohesion) 
  - 



##### 模块整体思路

- 经验表明，一个模块的规模不应过大，最好能写在一页纸内。通常规定50~100行语句，最多不超过500行。数字只能作为参考，根本问题是要保证模块的独立性。
- 过大的模块往往是由于分解不充分，但是进一步分解必须符合问题结构，一般说来，分解后不应该降低模块独立性。 
- 过小的模块开销大于有效操作，而且模块数目过多将使系统接口复杂。 

##### 模块定量指标

- 深度：软件结构中控制的层数，它往往能粗略地标志一个系统的大小和复杂程度。 
- 宽度：软件结构内同一个层次上的模块总数的最大值。
- 扇出：一个模块直接控制(调用)的模块数目。 
- 扇入：有多少个上级模块直接调用它。 

##### 模块作用域应该在控制域之内 

- 模块的作用域：定义为受该模块内一个判定影响的所有模块的集合。 
- 模块的控制域：是这个模块本身以及所有直接或间接从属于它的模块的集合。 
- 在一个设计得很好的系统中，所有受判定影响的模块应该都从属于做出判定的那个模块，最好局限于做出判定的那个模块本身及它的直属下级模块。

##### 模块接口复杂度

- 模块接口复杂是软件发生错误的一个主要原因。
- 应该仔细设计模块接口，使得信息传递简单并且和模块的功能一致。 

##### 设计单入口单出口的模块 
- 不要使模块间出现内容耦合 。
- 当从顶部进入模块并且从底部退出来时，软件是比较容易理解的，因此也是比较容易维护的 。

##### 模块功能可预测 

- 如果一个模块可以当做一个黑盒子，只要输入的数据相同就产生同样的输出，这个模块的功能就是可以预测的。





#### 描绘软件结构的图形

- ##### 层次图(H图) 

  - 层次图用来描绘软件的层次结构。很适于在自顶向下设计软件的过程中使用。

- ##### HIPO图 

  - 层次图+输入/处理/输出图。
  - 为了能使HIPO图具有可追踪性，在H图(层次图)里除了最顶层的方框之外，每个方框都加了编号。 

- ##### 结构图 

  - 方框代表一个模块。
  - 方框之间的直线表示模块的调用关系。
  - 尾部是空心圆箭头表示传递的是数据。
  - 尾部实心圆箭头表示传递的是控制信息。 



#### 面向数据流的设计方法

- 面向数据流的设计方法定义了一些不同的“映射”，利用这些映射可以把数据流图变换成软件结构。
- 因为任何软件系统都可以用数据流图表示，所以面向数据流的设计方法理论上可以设计任何软件的结构。通常所说的结构化设计方法(简称SD方法)，也就是基于数据流的设计方法。

##### 概念

- 变换流 ：信息沿输入通路进入系统，同时由外部形式变换成内部形式，进入系统的信息通过变换中心，经加工处理以后再沿输出通路变换成外部形式离开软件系统。

- 事务流：数据沿输入通路到达一个处理T，T根据输入数据的类型在若干个动作序列中选出一个来执行。 

  - 处理T称为事务中心，它完成下述任务：

  - 接收输入数据 

  - 分析每个事务以确定它的类型

  - 根据事务类型选取一条活动通路

    







