

## 深入理解Java虚拟机

[TOC]



### 如何阅读这本书

- 这本书的特点就是内容特别无聊
- 所以为了能看下去必须用问题驱动的方法



### Java对象相关问题

#### 描述一下java内存区域

- 程序计数器
  - 较小的内存空间
  - 线程所执行的字节码的行号指示器
  - 线程私有
  - 执行java方法，记录字节码指令地址
  - 执行native，记录值为空
- java虚拟机栈
  - 线程私有
  - 生命周期=线程
  - 结构：栈帧（stack frame）
  - 栈帧
    - 局部变量表：基本数据类型和对象引用
    - 操作数栈
    - 动态链接
    - 方法出口信息
  - 栈过深，容易StackOverflowError
  - 栈内存过大容易：OutOfMemoryError
- 本地方法栈
  - 执行native 方法
  - 其余类似java虚拟机栈
- Java堆
  - 内存中最大的一块
  - 存放对象实例
  - 垃圾收集器主要管理的区域
  - 新生代，老年代：eden , from survivor , to survivor 
  - 线程共享私有的分配缓冲区（Thread Local Allocation Buffer,TLAB）
  - Xmx Xms控制
- 方法区
  - 线程共享的内存区域
  - 存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码
  - 也叫永久代
- 运行时常量池
  - 方法区的一部分
  - 存放各种字面量和符号引用
- 直接内存
  - 不受java虚拟机堆限制，受本机内存限制
  - 为NIO快速读写而设计的



#### 对象的结构

- 对象头-HEARDER
  - 存储自身运行时的数据：哈希码，GC代，锁状态，线程持有锁，偏向线程ID，偏向时间戳
  - Mark Word - 非固定的数据结构。为了在更小的空间存储更多信息。详细内容请百度
  - 类型指针，即对象指向它的类元数据的指针，这个指针用来最终确定对象的实例
- 实例数据-INSTANCE DATA
  - 存储真正有效的信息
  - 各种字段的内容
  - 分配策略：longs/doubles,ints,shorts/chars.bytes/booleans,oops
- 对齐填充-PADDING
  - 为了对整8字节的整数倍



#### 如何创建对象

- new
- 检查指令参数是否能在常量池中定位到一个类的符合引用
- 检查符号应用是否已被加载，解析，初始化过
- 然后就是加载
- 分配内存
- 对象访问定位
  - 句柄访问，会划分出一块内存来作为句柄池，存放句柄地址
  - 直接指针访问，同样需要考虑存放指针
- 

#### 如何解决OOM异常

- 什么是OOM
  - 内存溢出
  - 说白了就是内存不够用了
- Java堆溢出
  - 对象太多超过堆容量限制
- 虚拟机栈和本地方法栈溢出
  - -Xss
  - 申请栈深度和栈本身变量
- 方法去和运行时常量池溢出
  - String问题
- 本机直接内存溢出
  - 申请directByteBuffer容易溢出





### 虚拟机本身相关问题

#### 简述一下垃圾收集器

- 如何确定对象无效
  - 引用计数算法
  - 可达性算法
- 细化引用概念
  - 强引用
  - 软引用
  - 弱引用
  - 虚引用
- 如何收集无效对象
  - 标记-清除算法（Mark-Sweep）
  - 复制算法（Copying）
  - 标记-整理算法（Mark-Compact）
  - 分代收集算法，整合了上面三种算法，在不同代用不同的算法罢了
- 收集垃圾中的难点
  - 枚举根结点
  - 安全点
  - 安全区域
- 垃圾收集器的品种
  - Serial收集器-单线程模式
  - ParNew收集器-多线程模式
  - CMS收集器-并发标记清除收集器
    - 目的：一种获取最短回收停顿时间为目标的收集器
    - 优点：并发收集，低停顿
    - 初始标记
    - 并发标记
    - 重新标记
    - 并发清除
    - 其中初始和重新标记需要短暂的STOP THE WORLD
    - 缺点：
      - 占用CPU资源非常敏感
      - 无法处理浮动垃圾，因为边收集同时也程序也会运行还会产出新垃圾等到下次收集
      - 产生大量空间碎片
  - G1收集器
    - 并行与并发，加快收集速度，减少停顿时间
    - 分代收集，提高效率，不同用适应的算法
    - 空间整合，减少碎片
    - 可预测的停顿。新的特性！
    - 采用Region作为收集的最小单位，分别为每个区域定义垃圾回收代价
    - 初始标记
    - 并发标记
    - 重新标记
    - 筛选回收

#### 如何看懂GC日志

- 

#### 虚拟机如何分配内存

- 可对照着回收的具体策略

- 对象优先在Eden分配
- 大对象直接进入老年代
- 长期存活的对象将进入老年代
- 动态对象年龄判定
- 空间分配担保
- 

#### 如何监控虚拟机

- 工具
  - jps：虚拟机进程状况工具
  - 





#### 如何优化虚拟机

- 最好包含实战案例内容









### 虚拟机执行相关问题

#### 类-虚拟机开始的入口

- 类的结构
  - 一组以8位字节为基础单位的二进制流
  - 各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，有效数据密度非常高
  - 数据类型
  - 无符号数
    - u1,u2.u4,u8代表1个字节，2个字节，4个字节，8个字节
    - 可以描述数字，索引引用，数量值或者字符串值
  - 表
    - 相当于多个无符号数整合的数据类型
    - 一种类似struct数据结构
    - 以_info结尾
  - 字节序：big-Endian
  - 

#### 如何加载类

- 用加载器加载

- 生命周期
- 加载
  - 通过一个类的全限定名来获取定义此类的二进制字节流
  - 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
  - 在内存中生成一个代表这个类的java.lang.class对象，作为方法区这个类的各种数据的访问入口
  - 数组的加载
    - 如果数组的组件类型是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将在加载该组件类型的类加载器的类名称空间上被标识
- 验证
  - 确保Class文件字节流包含信息符合当前版本虚拟机要求
  - 文件格式的验证
  - 元数据的验证
  - 字节码的验证
  - 符号引用验证
- 准备
  - 正式为类变量分配内存并设置类变量初始值的阶段，内存都在方法区中进行分配
  - 仅分配static变量
- 解析
  - 将常量池的符号引用替换为直接引用的过程
  - 直接引用和符号引用的关系
  - 类或接口的解析
  - 字段解析
  - 类方法解析
  - 接口方法解析
- 初始化
  - 执行类构造器的过程
  - <clinit>()
  - 
- 使用
- 卸载



#### 描述一下类加载器

- 实现类的加载动作
- 每一个类加载器都拥有一个独立的类名称空间
  - 比较两个类是否相等，只有两个类在同一加载器加载的前提下才有意义
  - 否则不可能相等，即使是同一个类
- 双亲委派模型
  - 启动类加载器
  - 扩展类加载器
  - 应用程序加载器
  - 除了启动类加载器无父类，其余都应当有父类
  - 父类更多体现在组合，而不是继承。达到复用的效果
  - 如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，不停上传的顶层父类，只有当父类无法加载请求时，才会开始让子类尝试去加载
  - 保证java类之间的统一，稳定有效也可以扩展。
- 类加载的突破
  - 线程上下文类加载器
  - 程序动态性，代码热替换，模块热部署。这样修改代码，不需要重新启动，就能生效



### 虚拟机字节码到底是什么





### Java编译器相关问题